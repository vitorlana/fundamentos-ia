# -*- coding: utf-8 -*-
"""TP1_completo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mDi2VcETTnLY1T_4nHsyRHIECWpxjkiu
"""

import random
import copy
from collections import deque
import time
import heapq
import time


# =========================
# TAREFA 1: Verificar se o tabuleiro é solucionável
# =========================

def contar_inversoes(tabuleiro):
    """Conta o número de inversões no tabuleiro (ignorando o espaço vazio)."""
    plano = [num for linha in tabuleiro for num in linha if num != 0]
    inversoes = 0
    for i in range(len(plano)):
        for j in range(i + 1, len(plano)):
            if plano[i] > plano[j]:
                inversoes += 1
    return inversoes

def posicao_linha_vazio(tabuleiro):
    """Retorna a linha do espaço vazio, contando de baixo para cima."""
    for i in range(4):
        if 0 in tabuleiro[i]:
            return 4 - i  # linhas de baixo para cima

def eh_soluvel(tabuleiro):
    """Verifica se uma configuração do tabuleiro é solucionável"""
    inversoes = contar_inversoes(tabuleiro)
    linha_vazio = posicao_linha_vazio(tabuleiro)

    if (linha_vazio % 2 == 0 and inversoes % 2 == 1) or \
       (linha_vazio % 2 == 1 and inversoes % 2 == 0):
        return True
    else:
        return False

def gerar_tabuleiro_aleatorio():
    """Gera uma configuração aleatória do tabuleiro 4x4 (não garante solução)."""
    tabuleiro = list(range(1, 16)) + [0]  # 0 representa o espaço vazio
    random.shuffle(tabuleiro)
    return [tabuleiro[i:i+4] for i in range(0, 16, 4)]

# =========================
# TESTE
# =========================

# tabuleiro = gerar_tabuleiro_aleatorio()
# for linha in tabuleiro:
#     print(linha)
# print("É solucionável?" , eh_soluvel(tabuleiro))

# =========================
# TAREFA 2: Gerar estado inicial aleatório e solucionável
# =========================

# Configuração objetivo
objetivo = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9,10,11,12],
    [13,14,15, 0]
]


# Direções de movimento (cima, baixo, esquerda, direita)
movimentos = [(-1,0), (1,0), (0,-1), (0,1)]

def encontrar_posicao_vazio(tabuleiro):
    """Encontra a posição do espaço vazio (0)."""
    for i in range(4):
        for j in range(4):
            if tabuleiro[i][j] == 0:
                return i, j

def mover(tabuleiro, direcao):
    """Move a peça na direção indicada, se possível."""
    i, j = encontrar_posicao_vazio(tabuleiro)
    di, dj = direcao
    ni, nj = i + di, j + dj

    if 0 <= ni < 4 and 0 <= nj < 4:
        tabuleiro[i][j], tabuleiro[ni][nj] = tabuleiro[ni][nj], tabuleiro[i][j]
        return True
    return False

def gerar_estado_inicial_soluvel(qtd_movimentos=100):
    """
    Gera uma configuração inicial válida do jogo 15-puzzle,
    aplicando movimentos aleatórios a partir do estado objetivo.
    """
    tabuleiro = copy.deepcopy(objetivo)
    ultimo_movimento = None

    for _ in range(qtd_movimentos):
        movs_validos = movimentos.copy()

        # Evita desfazer o último movimento
        if ultimo_movimento:
            oposto = (-ultimo_movimento[0], -ultimo_movimento[1])
            if oposto in movs_validos:
                movs_validos.remove(oposto)

        random.shuffle(movs_validos)

        for direcao in movs_validos:
            if mover(tabuleiro, direcao):
                ultimo_movimento = direcao
                break

    return tabuleiro

# =========================
# TESTE
# =========================

# print("=== Gerando estado inicial SOLUCIONÁVEL ===")
# tabuleiro_soluvel = gerar_estado_inicial_soluvel()
# for linha in tabuleiro_soluvel:
#     print(linha)
# print("É solucionável?", eh_soluvel(tabuleiro_soluvel))

# print("\n=== Gerando estado ALEATÓRIO (pode ser insolúvel) ===")
# tabuleiro_aleatorio = gerar_tabuleiro_aleatorio()
# for linha in tabuleiro_aleatorio:
#     print(linha)
# print("É solucionável?", eh_soluvel(tabuleiro_aleatorio))

# =========================
# TAREFA 3: Implementar BFS e DFS
# =========================
# =========================
# Utilitários de Estado
# =========================

def tabuleiro_para_estado(tabuleiro):
    """Converte o tabuleiro 2D para uma tupla 1D."""
    return tuple(num for linha in tabuleiro for num in linha)

def estado_para_tabuleiro(estado):
    """Converte um estado (tupla 1D) para matriz 4x4."""
    return [list(estado[i:i+4]) for i in range(0, 16, 4)]

def encontrar_zero(estado):
    """Retorna índice (linha, coluna) do espaço vazio (0)."""
    idx = estado.index(0)
    return divmod(idx, 4)

def movimentos_validos(i, j):
    """Retorna lista de direções válidas a partir da posição (i,j)."""
    direcoes = []
    if i > 0: direcoes.append((-1, 0))  # cima
    if i < 3: direcoes.append((1, 0))   # baixo
    if j > 0: direcoes.append((0, -1))  # esquerda
    if j < 3: direcoes.append((0, 1))   # direita
    return direcoes

def mover_estado(estado, direcao):
    """Aplica um movimento e retorna novo estado."""
    i, j = encontrar_zero(estado)
    ni, nj = i + direcao[0], j + direcao[1]
    if 0 <= ni < 4 and 0 <= nj < 4:
        novo = list(estado)
        idx1, idx2 = i * 4 + j, ni * 4 + nj
        novo[idx1], novo[idx2] = novo[idx2], novo[idx1]
        return tuple(novo)
    return None

# =====================
# BFS (Busca em Largura)
# =====================

def bfs(inicial, objetivo):
    fila = deque()
    fila.append((inicial, []))
    visitados = set()
    visitados.add(inicial)
    nos_expandidos = 0

    while fila:
        estado_atual, caminho = fila.popleft()
        nos_expandidos += 1

        if estado_atual == objetivo:
            return caminho, nos_expandidos

        i, j = encontrar_zero(estado_atual)
        for direcao in movimentos_validos(i, j):
            novo_estado = mover_estado(estado_atual, direcao)
            if novo_estado and novo_estado not in visitados:
                visitados.add(novo_estado)
                fila.append((novo_estado, caminho + [novo_estado]))

    return None, nos_expandidos

# =====================
# DFS (Busca em Profundidade)
# =====================

def dfs(inicial, objetivo, profundidade_maxima):
    pilha = [(inicial, [], 0)]  # (estado, caminho, profundidade)
    visitados = set()
    visitados.add(inicial)
    nos_expandidos = 0

    while pilha:
        estado_atual, caminho, profundidade = pilha.pop()
        nos_expandidos += 1

        if estado_atual == objetivo:
            return caminho, nos_expandidos

        if profundidade < profundidade_maxima:
            i, j = encontrar_zero(estado_atual)
            for direcao in movimentos_validos(i, j):
                novo_estado = mover_estado(estado_atual, direcao)
                if novo_estado and novo_estado not in visitados:
                    visitados.add(novo_estado)
                    pilha.append((novo_estado, caminho + [novo_estado], profundidade + 1))

    return None, nos_expandidos

# =========================
# TESTE
# =========================

# tabuleiro_soluvel = gerar_estado_inicial_soluvel(qtd_movimentos=10)
# for linha in tabuleiro_soluvel:
#     print(linha)
# print("É solucionável?", eh_soluvel(tabuleiro_soluvel))
#
# inicial = tabuleiro_para_estado(tabuleiro_soluvel)
# meta = tabuleiro_para_estado(objetivo)
#
# print("\n[Busca em Largura - BFS]")
# sol_bfs, exp_bfs = bfs(inicial, meta)
# print("Nós expandidos:", exp_bfs)
# print("Passos até solução:", len(sol_bfs) if sol_bfs else "Não encontrada")
#
# print("\n[Busca em Profundidade - DFS]")
# sol_dfs, exp_dfs = dfs(inicial, meta, 30) # profundidade ajustavél aqui
# print("Nós expandidos:", exp_dfs)
# print("Passos até solução:", len(sol_dfs) if sol_dfs else "Não encontrada")

# =========================
# TAREFA 4: Heurística e A*
# =========================


# =========================
# Função Heurística: Distância de Manhattan
# =========================

def distancia_manhattan(estado):
    """Calcula a soma das distâncias de Manhattan para todas as peças."""
    distancia = 0
    for idx, valor in enumerate(estado):
        if valor != 0:
            linha_atual, coluna_atual = divmod(idx, 4)
            linha_objetivo, coluna_objetivo = divmod(valor - 1, 4)
            distancia += abs(linha_atual - linha_objetivo) + abs(coluna_atual - coluna_objetivo)
    return distancia

# =========================
# Busca A* (A Estrela)
# =========================

def a_star(inicial, objetivo):
    """Busca A* para resolver o 15-puzzle."""
    fila = []
    heapq.heappush(fila, (distancia_manhattan(inicial), 0, inicial, []))  # (f, g, estado, caminho)
    visitados = set()
    visitados.add(inicial)
    nos_expandidos = 0

    while fila:
        f, g, estado_atual, caminho = heapq.heappop(fila)
        nos_expandidos += 1

        if estado_atual == objetivo:
            return caminho, nos_expandidos

        i, j = encontrar_zero(estado_atual)
        for direcao in movimentos_validos(i, j):
            novo_estado = mover_estado(estado_atual, direcao)
            if novo_estado and novo_estado not in visitados:
                visitados.add(novo_estado)
                novo_caminho = caminho + [novo_estado]
                novo_g = g + 1
                novo_f = novo_g + distancia_manhattan(novo_estado)
                heapq.heappush(fila, (novo_f, novo_g, novo_estado, novo_caminho))

    return None, nos_expandidos

def mostrar_passos_da_solucao(solucao):
    if not solucao:
        return ["Nenhuma solução encontrada."]
    steps = ["--- Nova Solução ---"]
    for i, estado in enumerate(solucao, start=1):
        tab = estado_para_tabuleiro(estado)
        steps.append(f"Passo {i}")
        for linha in tab:
            steps.append(str(linha))
        steps.append('')
    return steps

def converter_caminho_em_direcoes(estado_inicial, caminho):
    dirs = []
    atual = estado_inicial
    for prox in caminho:
        i1, j1 = encontrar_zero(atual)
        i2, j2 = encontrar_zero(prox)
        if i2 < i1:
            dirs.append("cima")
        elif i2 > i1:
            dirs.append("baixo")
        elif j2 < j1:
            dirs.append("esquerda")
        else:
            dirs.append("direita")
        atual = prox
    return dirs

# # # Gerar um tabuleiro inicial SOLUCIONÁVEL
# tabuleiro_soluvel = gerar_estado_inicial_soluvel(qtd_movimentos=10)
# print("Tabuleiro inicial:")
# for linha in tabuleiro_soluvel:
#     print(linha)
# print("É solucionável?", eh_soluvel(tabuleiro_soluvel))
#
# # Preparar estados
# inicial = tabuleiro_para_estado(tabuleiro_soluvel)
# meta = tabuleiro_para_estado(objetivo)
#
# # =====================
# # Testar BFS
# # =====================
# print("\n[Busca em Largura - BFS]")
# start_time = time.time()
# sol_bfs, exp_bfs = bfs(inicial, meta)
# end_time = time.time()
# tempo_bfs = end_time - start_time
#
# if sol_bfs:
#     print("Solução encontrada!")
#     print("Movimentos até solução:", len(sol_bfs))
#     mostrar_passos_da_solucao(sol_bfs)
# else:
#     print("Solução NÃO encontrada!")
# print("Nós expandidos:", exp_bfs)
# print(f"Tempo: {tempo_bfs:.4f} segundos")
#
# # =====================
# # Testar DFS
# # =====================
# print("\n[Busca em Profundidade - DFS]")
# start_time = time.time()
# sol_dfs, exp_dfs = dfs(inicial, meta, profundidade_maxima=30) # profundidade ajustavél aqui
# end_time = time.time()
# tempo_dfs = end_time - start_time
#
# if sol_dfs:
#     print("Solução encontrada!")
#     print("Movimentos até solução:", len(sol_dfs))
#     mostrar_passos_da_solucao(sol_dfs)
# else:
#     print("Solução NÃO encontrada!")
# print("Nós expandidos:", exp_dfs)
# print(f"Tempo: {tempo_dfs:.4f} segundos")
#
# # =====================
# # Testar A*
# # =====================
# print("\n[Busca A* - A Star]")
# start_time = time.time()
# sol_a_star, exp_a_star = a_star(inicial, meta)
# end_time = time.time()
# tempo_a_star = end_time - start_time
#
# if sol_a_star:
#     print("Solução encontrada!")
#     print("Movimentos até solução:", len(sol_a_star))
#     mostrar_passos_da_solucao(sol_a_star)
# else:
#     print("Solução NÃO encontrada!")
# print("Nós expandidos:", exp_a_star)
# print(f"Tempo: {tempo_a_star:.4f} segundos")



